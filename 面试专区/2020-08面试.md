## 1. 计算机基础

### 1.1 计算机网络

**网络模型**（OSI七层模型，TCP/IP四层模型，五层协议结构）应用层，传输层，网络层，链路层

**TCP和UDP的区别**（TCP：面向连接的，可靠的 UDP：不可靠，传输速度快，不需要连接，广播），三次握手，四次挥手，TCP协议保证可靠（ARQ协议，滑动窗口流量控制，拥塞控制）

DNS协议，ARP协议，MAC地址，CDN

HTTP协议：**请求方式**(get，post，put，delete)，**状态码**（1XX，2XX，3XX，4XX，5XX），**HTTP和HTTPS SSL**，**请求报文和响应报文**，HTTP 1.1 和2.0

> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

传输流程（地址解析，封装HTTP请求数据包，封装成TCP包建立连接，发送请求）

### 1.2 网络安全

DDos攻击，SQL注入攻击，XSS攻击

### 1.3 加密算法

加密算法，

哈希算法 md5，

对称加密 des，aes，非对称加密 rsa

### 1.4 授权、认证

授权、认证框架(Shiro，Security)

### 1.5 操作系统

linux：常用命令

Ls,mkdir,cd,mkdir,cp,mv,tail,grep,find,tail,pwd,cat,....

## 2. 数据结构与算法

### 2.1 数据结构

数组: 连续地址存储，动态扩容，查找O(1)，插入，删除O(n)

链表：单链表，双向链表，循环链表，双向循环链表，非线性存储，查找O(n)，插入，删除O(1)

栈：先进后出，顺序栈，链式栈，查找O(n)，插入，删除O(1)，浏览器回退和前进，字符串翻转

队列：先进先出，单队列，循环队列，顺序队列，链式队列，查找O(n)，插入，删除O(1)，阻塞队列

散列表：数组扩展，散列函数，散列值

跳表：链表加多级索引

树：高度，深度，层，二叉树（满二叉树，完全二叉树，前序遍历，中序遍历，后续遍历），二叉查找树，平衡二叉查找树，红黑树，[B+树](https://time.geekbang.org/column/article/77830)(数据库索引)，B+树

### 2.2 算法

查找算法：顺序查找，二分查找，插值查找，斐波那契查找，二叉树查找，红黑树查找，分块查找，哈希查找

排序算法：冒泡排序，选择排序，插入排序，希尔排序（缩小增量排序），归并排序，快速排序(基准值)，堆排序

数组系列：公共元素

字符串系列：翻转，相加

## 3. Java

### 3.1 Java基础

JVM，JDK和JRE，解释器和编译器(JIT)，数据类型（boolean，char，short，integer，long，double，float，byte），String（final，String StringBuffer 和 StringBuilder），final，static，继承、封装、多态，接口和抽象类，反射，异常（error，exception，RuntimeException，checkedException ），重载与重写， 注解，内部类，序列化(transient)，泛型（类型擦除），装箱和拆箱，常量池（0，127）,值传递和引用传递，重载和重写，深拷贝和浅拷贝，

==（内存地址）和equals（值）的区别

hashCode()与 equals()

> Object类里面的默认eqals方法是比较内存地址是否相等，默认的hashCode方法则是根据内存地址产生一个整数，所以Object类本身当然是符合上面规则的。当你覆盖了equals后，内存地址不同的对象可能会相等，而如果这时你没有覆盖hashCode方法的话，hashCode还是根据内存地址来生成，就会出现相等的对象具有不同的散列码的情况。

Object类的常用方法（hashCode，equals，toString，notify，notifyAll，wait）

> Wait()：object的方法，释放锁，线程交互

BIO、NIO、AIO：多路复用，异步IO，select、poll、epoll，内核空间，用户空间

> I/O多路复用就是通过一种机制，一个进程可以监视多个描述符(客户端连接)，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
>
> select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。
>
> epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。

### 3.2 Java集合

List（ArrayList，LinkedList，Vector，Stack），

Set（HashSet 常数级，无序，TreeSet logn，有序，LinkedHashSet），

Queue/Deque 双端队列（PriorityQueue，LinkedList，ArrayDeque），

Map（Hashtable 安全、HashMap不安全、TreeMap 有序，LinkedHashMap 有序），HashMap和ConcurrentHashMap 1.7和1.8

> HashMap和ConcurrentHashMap 1.7和1.8：结构，put流程

### 3.3 Java并发

内存模型：原子性(Lock，synchronized，cas)，可见性（volatile），顺序性

多线程：线程创建(thread，runnable，线程池)，生命周期(start，runnable，running，blocked，dead)，中断线程（Interrupt），基本方法（wait，sleep，yield，interrupt，join，notify），死锁，守护线程

锁：乐观锁，悲观锁，自旋锁，适应性自旋锁，偏向锁，轻量级锁，重量级锁，公平锁，非公平锁，可重入锁，非可重入锁，独享锁，共享锁）

Java线程池：corePoolSize，maxPoolSize，4种线程池(corePoolSize=maxPoolSize，single，定时队列，)，拒绝策略

volatile：可见性

ThreadLocal：ThreadLoclMap

Synchronized VS ReentrantLock：都是可重入锁，显示获得锁，释放锁，可中断，公平锁，底层原理

并发容器：ConcurrentHashMap，CopyOnWriteArrayList，CopyOnWriteArraySet，ConcurrentLinkedQueue，ConcurrentSkipListMap，ArrayBlockingQueue，DelayQueue

原子类：CAS，基本数据类型原子类 AtomicInteger，数组类型原子类 AtomicIntegerArray，引用类型原子类 AtomicReference，字段类型原子类 AtomicIntegerFieldUpdater

CAS：

AQS：公平锁，非公平锁

> 公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。非公平锁，在等待锁的过程中， 如果有任意新的线程妄图获取锁，都是有很大的几率直接获取到锁的。

### 3.4 Java 设计模式

https://www.runoob.com/design-pattern/design-pattern-tutorial.html

创建型：工厂模式，单例模式，建造者模式，原型模式

> 简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。

行为型：代理模式，适配器模式，享元模式

> 代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。

应用型：观察者模式，策略模式(发放会员卡服务权益)

### 3.5 Java虚拟机

**内存区域**：线程私有（程序计数器，Java虚拟机栈（方法执行的内存模型），本地方法栈），**Java堆**(新生代，老年代，永久代)，方法区（常量池），直接内存

**GC算法**：对象存活判定（引用计数法，可达性分析算法），垃圾收集算法（标记-清除，复制算法（新生代回收算法）,标记-整理（老年代算法））

内存分配策略：优先Eden区分配，大对象进入老年代，

**垃圾收集器**：新生代收集器（Serial收集器（单线程，复制算法，新生代收集器），ParNew 收集器（多线程，复制算法，新生代收集器），Parallel Scavenge 收集器（与ParNew类似，可控制的吞吐量）），老年代收集器（Serial Old收集器（单线程，标记-整理），Parallel Old收集器（多线程，标记-整理），CMS收集器（标记-清除，并发，低停顿）），G1收集器

**类加载机制**：加载，验证，准备，解析，初始化

**类加载器**：双亲委派模型，破坏双亲委派模型（SPI），自定义类加载器，OSGI

**jvm调优**：活跃数据，JVM参数，内存泄漏，内存溢出

### 3.6 Java 框架

Spring：IOC实现机制，bean解析，注册，实例化流程，AOP，jdk动态代理，cglib，事务，设计模式，注解，切面

> 1. 加载xml文件
> 2. 解析xml文件为document文档对象
> 3. 解析document文档对象为beandefinition
> 4. 加载beandefinition到beanFactory,beandefinitionMap=beanName->beanDefinition
> 5. 实例化单例
> 6. 实例化依赖
> 7. 创建bean
> 8. 注入属性
> 9. 回调*aware，BeanPostProcessor.postProcessBeforeInitialization,initmethod,BeanPostProcessor.postProcessAfterInitialization

Spring MVC：主要组件，DispatcherServlet，常用注解，流程

Mybatis：解析和运行原理，缓存，动态sql，返回映射，延迟加载

Spring Boot：自动配置，配置文件加载顺序 bootstarap

Netty：NIO，线程模型，Reactor线程模型

## 4. 数据库

### 4.1 Mysql

基础：三大范式，sql，redolog，binlog，undolog，存储引擎（innodb，myisam）

事务：隔离级别，四大特性（acid）

并发控制：乐观锁，悲观锁，mvvc，表锁，行锁，间隙锁

高可用：分区，读写分离，分库分表，主从同步

sql优化：explain

索引：B+，回表，最左匹配

备份和恢复：binlog

### 4.2 Redis

单线程模型：IO多路复用

数据结构：String，List，Set，Hash，Zset

回收策略：直接报错，移除最近使用少的key，随机移除key...

持久化：AOF，RDB

事务: MULTI，EXEC，DISCARD

复制：RDB

高可用：哨兵模式，数据分区，主从复制

解决方案：分布式锁，限流，缓存雪崩，缓存穿透

客户端：jedis，redisson

## 5. 微服务

服务注册与发现：Zookeeper（CP），Consule（CP），Eureka（AP），Nacos（CP）

负载均衡：Ribbon，策略（轮询，随机，最大可用，加权轮询，自定义）

容错隔离降级：Hystrix，线程隔离（线程池，信号量），熔断器，回退降级

服务调用：Feign

网关服务：Gateway，Zuul

配置管理：Config

消息总线：Spring Cloud Bus

链路追踪：Sleuth

应用监控：Spring Boot Admin

流量：Sentinel

## 6. 系统架构

### 6.1 分布式

一致性协议和算法：cap理论，base理论，拜占庭将军问题，2PC，3PC，Paxos算法，Raft算法

Zookeeper：zab协议，数据结构（顺序节点，持久节点，临时节点，监听机制），使用场景：选举，服务注册发现，分布式锁

分布式锁：数据库，redis，zookeeper，redlock

分布式事务：2PC，3PC，AT方案，XA方案(数据库)，TCC，消息最终一致性，最大努力通知方案

分布式搜索引擎：elasticsearch

### 6.2 中间件

消息队列的好处：解耦，错峰和流控

RabbitMQ：架构（队列，消息，交换器(direct，topic，header，fanout)），可靠性（重复消息，丢失消息：持久化 ack 事务机制 confirm机制，消息顺序性），死信消息 TTL，消费模式（push，pull）

Kafka：分布式，持久化日志，topic  partition replica，pull，replica选举，可靠性（消息丢失 副本机制，重复消息 幂等，消息顺序性 partition）

RPC：动态代理，编码解码，序列化，通信，服务注册、发现（zookeeper）

日志系统：elk

数据库中间件：mycat 逻辑库，分库分表，读写分离，主从

### 6.3 系统设计

秒杀系统，高并发系统，红包系统

限流，分布式锁，redis库存，消息队列，lock，数据库乐观，悲观锁

## 7. 运维&测试

### 7.1 容器编排

docker：容器技术，镜像，容器，持久化，dockerfile，docker compose

k8s：

### 7.2 服务器

nginx（架构，负载均衡，特性）

### 7.3 负载均衡

SLB