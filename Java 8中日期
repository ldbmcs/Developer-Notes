## JSR 310

最开始的时候，Date既要承载日期信息，又要做日期之间的转换，还要做不同日期格式的显示，职责较繁杂（不懂单一职责，你妈妈知道吗？纯属恶搞~哈哈）

后来从JDK 1.1 开始，这三项职责分开了：

使用Calendar类实现日期和时间字段之间转换；
使用DateFormat类来格式化和分析日期字符串；
而Date只用来承载日期和时间信息。
原有Date中的相应方法已废弃。不过，无论是Date，还是Calendar，都用着太不方便了，这是API没有设计好的地方。

JSR 310实际上有两个日期概念。第一个是`Instant`，它大致对应于java.util.Date类，因为它代表了一个确定的时间点，即相对于标准Java纪元（1970年1月1日）的偏移量；但与java.util.Date类不同的是其精确到了纳秒级别。

第二个对应于人类自身的观念，比如`LocalDate`和`LocalTime`。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于java.sql的表示方式。此外，还有一个MonthDay，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像java.util.Date那样利用午夜12点来区分日期，利用1970-01-01来表示时间。

目前Java8已经实现了JSR310的全部内容。新增了java.time包定义的类表示了日期-时间概念的规则，包括instants, durations, dates, times, time-zones and periods。这些都是基于ISO日历系统，它又是遵循 Gregorian规则的。最重要的一点是值不可变，且线程安全，通过下面一张图，我们快速看下java.time包下的一些主要的类的值的格式，方便理解。


![](https://image.ldbmcs.com/2021-06-10-FEqxyy.jpg)

## Java8中日期、时间类的概述

![](https://image.ldbmcs.com/2021-06-10-sKCD4v.jpg)

所有类都实现了 Temporal 接口， Temporal 接口定义了如何读取和操纵

java8引入了一套全新的时间日期API。java.time包中的是类是不可变且线程安全的。新的时间及日期API位于java.time中，下面是一些关键类：

1. Instant——它代表的是时间戳（另外可参考Clock类）
2. LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。
3. LocalTime——它代表的是不含日期的时间
4. LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。
5. ZonedDateTime——这是一个包含时区的完整的日期时间还有时区，偏移量是以UTC/格林威治时间为基准的。
6. Timezones——时区。在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。

![](https://image.ldbmcs.com/2021-06-10-9KlNIc.jpg)

### ZonedDateTime(带时区的 日期和时间)

Java8使用ZoneId来标识不同的时区。

```java
public static void main(String[] args) {
    //获得所有可用的时区  size=600 这个数字不是固定的
    Set<String> allZones = ZoneId.getAvailableZoneIds();
    //获取默认ZoneId对象 系统当前所在时区
    ZoneId defZoneId = ZoneId.systemDefault();
    //获取指定时区的ZoneId对象
    ZoneId shanghaiZoneId = ZoneId.of("Asia/Shanghai");
    //ZoneId.SHORT_IDS返回一个Map<String, String> 是时区的简称与全称的映射。下面可以得到字符串 Asia/Shanghai
    String shanghai = ZoneId.SHORT_IDS.get("CTT");
    System.out.println(shanghai); //Asia/Shanghai
}
```

```java
public static void main(String[] args) {
    //2017-01-20T17:35:20.885+08:00[Asia/Shanghai]
    ZonedDateTime now = ZonedDateTime.now();
    //2017-01-01T12:00+08:00[Asia/Shanghai]
    ZonedDateTime of = ZonedDateTime.of(2017, 1, 1, 12, 0, 0, 0, ZoneId.of("Asia/Shanghai"));
    //使用一个准确的时间点来创建ZonedDateTime，下面这个代码会得到当前的UTC时间，会比北京时间早8个小时
    ZonedDateTime utc = ZonedDateTime.ofInstant(Instant.now(), ZoneId.of("UTC"));
    System.out.println(now); //2018-08-04T18:53:24.686+08:00[Asia/Shanghai]
    System.out.println(of); //2017-01-01T12:00+08:00[Asia/Shanghai]
    System.out.println(utc); //2018-08-04T10:53:24.687Z[UTC]
}
```

### LocalDateTime、OffsetDateTime、ZonedDateTime

![](https://image.ldbmcs.com/2021-06-10-9KlNIc.jpg)

在JSR 310日期时间体系了，一共有三个API可用于表示日期时间：

- LocalDateTime：本地日期时间
- OffsetDateTime：带偏移量的日期时间
- ZonedDateTime：带时区的日期时间

### 什么是LocalDateTime？

![](https://image.ldbmcs.com/2021-06-10-RQIHMW.jpg)

ISO-8601日历系统中不带时区的日期时间。

> 说明：ISO-8601日系统是现今世界上绝大部分国家/地区使用的，这就是我们国人所说的公历，有闰年的特性

LocalDateTime是一个不可变的日期-时间对象，它表示一个日期时间，通常被视为年-月-日-小时-分钟-秒。还可以访问其他日期和时间字段，如day-of-year、day-of-week和week-of-year等等，它的精度能达纳秒级别。

该类不存储时区，所以适合日期的描述，比如用于生日、deadline等等。但是请记住，如果没有偏移量/时区等附加信息，一个时间是不能表示时间线上的某一时刻的。

### 什么是OffsetDateTime？

![](https://image.ldbmcs.com/2021-06-10-DkKNiQ.jpg)

ISO-8601日历系统中与UTC偏移量有关的日期时间。OffsetDateTime是一个带有偏移量的日期时间类型。存储有精确到纳秒的日期时间，以及偏移量。可以简单理解为 OffsetDateTime = LocalDateTime + ZoneOffset。

OffsetDateTime、ZonedDateTime和Instant它们三都能在时间线上以纳秒精度存储一个瞬间（请注意：LocalDateTime是不行的），也可理解我某个时刻。OffsetDateTime和Instant可用于模型的字段类型，因为它们都表示瞬间值并且还不可变，所以适合网络传输或者数据库持久化。

> ZonedDateTime不适合网络传输/持久化，因为即使同一个ZoneId时区，不同地方获取到瞬时值也有可能不一样

一个UTC偏移量 `offset-from-UTC` 仅仅只记录了时分秒而已，除此之外没有任何其他信息。举个例子 ，+08:00的意思时超前于UTC八个小时，而 -05:45 意思是落后于UTC五小时四十五分钟。

而时区对于特定地区的人来说是过去，现在，未来的偏移量的历史集合。**像夏令时这样的异常会导致特定时间段内的偏移量会随时间变化，无论是过去已经发生的还是 未来政客们宣布计划的改变。**

### 什么是ZonedDateTime？

![](https://image.ldbmcs.com/2021-06-10-b6WBVk.jpg)

ISO-8601国际标准日历系统中带有时区的日期时间。它存储所有的日期和时间字段，精度为纳秒，以及一个时区，带有用于处理不明确的本地日期时间的时区偏移量。

这个API可以处理从`LocalDateTime -> Instant -> ZonedDateTime`的转换，其中用zone时区来表示偏移量（并非直接用offset哦）。两个时间点之间的转换会涉及到使用从ZoneId访问的规则计算偏移量（换句话说：偏移量并非写死而是根据规则计算出来的）。

获取瞬间的偏移量很简单，因为每个瞬间只有一个有效的偏移量。但是，获取本地日期时间的偏移量并不简单。存在这三种情况：

1. 正常情况：有一个有效的偏移量。对于一年中的绝大多数时间，适用正常情况，即本地日期时间只有一个有效的偏移量

2. 时间间隙情况：没有有效偏移量。这是由于夏令时开始时从“冬季”改为“夏季”而导致时钟向前拨的时候。在间隙中，没有有效偏移量

3. 重叠情况：有两个有效偏移量。这是由于秋季夏令时从“夏季”到“冬季”的变化，时钟会向后拨。在重叠部分中，有两个有效偏移量

这三种情况如果要自己处理，估计头都大了。这就是使用JSR 310的优势，ZonedDateTime全帮你搞定，让你使用无忧。

ZonedDateTime可简单认为是LocalDateTime和ZoneId的组合。而ZoneOffset是其内置的动态计算出来的一个次要信息，以确保输出一个瞬时值而存在，毕竟在某个瞬间偏移量ZoneOffset肯定是确定的。ZonedDateTime也可以理解为保存的状态相当于三个独立的对象：LocalDateTime、ZoneId和ZoneOffset。某个瞬间 = LocalDateTime + ZoneOffset。ZoneId确定了偏移量如何改变的规则。所以偏移量我们并不能自由设置（不提供set方法，构造时也不行），因为它由ZoneId来控制的。

