> 转载：[微服务容错 - 隔离熔断限流](https://segmentfault.com/a/1190000020791119)

在高并发访问下，系统所依赖的服务的稳定性对系统的影响非常大，依赖有很多不可控的因素，比如网络连接变慢，资源突然繁忙，暂时不可用，服务脱机等。我们要构建稳定、可靠的分布式系统，就必须要有这样一套容错机制。常用的的容错技术如：隔离，降级，熔断，限流等策略，本文将详细的介绍微服务中的容错机制。

## 1. 隔离机制

为什么要隔离? 比如我们现在某个接口所在的服务A需要调用服务B，而服务B同时需要调用C服务，此时服务C突然宕机同时此时流量暴涨，调用全部打到服务B上，此时B服务调用C超时大量的线程资源被该接口所占全部hang住，慢慢服务B中的线程数量则会持续增加直致CPU资源耗尽到100%，整个服务对外不可用渐渐蔓延到B服务集群中的其他节点，导致服务级联故障。

![2020-08-11-3tWGdn](https://image.ldbmcs.com/2020-08-11-3tWGdn.jpg)

**此时我们就需要对服务出现异常的情况进行隔离，防止级联故障效应，常用的隔离策略有线程池隔离和信号量隔离**。

### 1.1 线程池隔离

线程池隔离顾名思义就是通过Java的线程池进行隔离，B服务调用C服务给予固定的线程数量比如10个线程，如果此时C服务宕机了就算大量的请求过来，调用C服务的接口只会占用10个线程不会占用其他工作线程资源，因此B服务就不会出现级联故障。

![2020-08-11-eX91zp](https://image.ldbmcs.com/2020-08-11-eX91zp.jpg)

### 1.2 信号量隔离

另一种隔离信号量隔离是使用`JUC`下的Semaphore来实现的，当拿不到信号量的时候直接拒接因此不会出现超时占用其他工作线程的情况。

```java
Semaphore semaphore = new Semaphore(10,true);
//获取信号量
semaphore.acquire();
//do something here
//释放信号量
semaphore.release();
```

### 1.3 比较

线程池隔离针对不同的资源分别创建不同的线程池，不同服务调用都发生在不同的线程池中，在线程池排队、超时等阻塞情况时可以快速失败。**线程池隔离的好处是隔离度比较高，可以针对某个资源的线程池去进行处理而不影响其它资源，但是代价就是线程上下文切换的 overhead 比较大，特别是对低延时的调用有比较大的影响。而信号量隔离非常轻量级，仅限制对某个资源调用的并发数，而不是显式地去创建线程池，所以 overhead 比较小，但是效果不错，也支持超时失败**。

| 比较项       | 线程池隔离                               | 信号量隔离                                                   |
| ------------ | ---------------------------------------- | ------------------------------------------------------------ |
| 线程         | 与调用线程不同，使用的是线程池创建的线程 | 与调用线程相同                                               |
| 开销         | 排队，切换，调度等开销                   | 无线程切换性能更高                                           |
| 是否支持异步 | 支持                                     | 不支持                                                       |
| 是否支持超时 | 支持超时                                 | **支持超时([新版本支持](https://www.codercto.com/a/77154.html))** |
| 并发支持     | 支持通过线程池大小控制                   | 支持通过最大信号量控制                                       |

## 2. 降级熔断机制

 什么是降级和熔断？降级和熔断有什么区别？虽然很多人把降级熔断当着一个词来说的，但是降级和熔断是完全不同的概念的，看看下面几种场景：

1. 场景一：比如我们每天上班坐公交，1路和2路公交都能到公司，但是2路公交需要下车走点路，所以平时都是坐1路公交，
   突然有一天等了1路公交好久都没来，于是就坐了2路公交作为替代方案总不能迟到吧！下次再等1路车。

2. 场景二：第二天，第三天 ... 已经一个星期了都没看到1路公交，心里觉得可能是1路公交改路线了，
   于是直接坐2路公交了，在接下来的日子里都是直接忽略1路车直接坐2路车

3. 场景三：突然有一天在等2路车的时候看到了1路车，是不是1路车现在恢复了，于是天天开心的坐着1路车上班去了，领导再也不担心我迟到了

场景一在1路车没等到的情况下采取降级方案坐2路车，这就是**降级策略**，场景二如果多次都没有等到1路车就直接不等了下次直接坐2路车，这就是**熔断策略**，场景三如果过段时间1路车恢复了就使用2路车，这就是**熔断恢复**！

### 2.1 降级机制

常用的降级策略如：**熔断器降级，限流降级，超时降级，异常降级，平均响应时间降级**等。

![2020-08-11-Vag0Bd](https://image.ldbmcs.com/2020-08-11-Vag0Bd.jpg)

- **熔断器降级：**即熔断器开启的时间直接熔断走降级的策略。
- **限流降级：**对流量进行限制达到降级的效果，如：`Hystrix`中的线程池，信号量都能达到限流的效果。
- **超时降级：**课时设置对应的超时时间如果服务调用超时了就执行降级策略，如：`Hystrix`中默认为1s。
- **异常降级：**异常降级很简单就是服务出现异常了执行降级策略。
- **平均响应时间降级：**服务响应时间持续飙高的时候实现降级策略，如Sentinel中默认的RT 上限是 4900 ms。

### 2.2 熔断机制

熔断其实是一个框架级的处理，那么这套熔断机制的设计，基本上业内用的是`Martin Fowler`提出的断路器模式，断路器的基本原理非常简单。**您将受保护的函数调用包装在断路器对象中，该对象将监视故障。一旦故障达到某个阈值，断路器将跳闸，并且所有进一步的断路器调用都会返回错误，而根本不会进行受保护的调用。常见的断路器模式有基本模式和扩展模式**。

#### 2.2.1 基本模式

- 如果断路器状态为close，则调用断路器将调用supplier服务模块；
- 如果断路器状态为open则直接返回错误；
- 如果超时，我们将增加失败计数器，成功的调用会将其重置为零；
- 通过比较故障计数和阈值来确定断路器的状态；

![2020-08-11-19kbf7](https://image.ldbmcs.com/2020-08-11-19kbf7.jpg)

#### 2.2.2 扩展模式

基础模式的断路器避免了在电路断开时发出受保护的呼叫，但是**当情况恢复正常时，将需要外部干预才能将其重置**。对于建筑物中的电路断路器，这是一种合理的方法，但是**对于软件断路器，我们可以让断路器本身检测基础调用是否再次正常工作**。我们可以通过在适当的时间间隔后再次尝试受保护的调用来实现这种自我重置行为，并在成功后重置断路器。于是就出现了扩展模式：

![2020-08-11-tCO3XK](https://image.ldbmcs.com/2020-08-11-tCO3XK.jpg)

- 最开始处于`closed`状态，一旦检测到错误到达一定阈值，便转为`open`状态；
- 这时候会有个 reset timeout，到了这个时间了，会转移到`half open`状态；
- 尝试放行一部分请求到后端，一旦检测成功便回归到`closed`状态，即恢复服务；

### 2.3 熔断策略

我们通常用以下几种方式来衡量资源是否处于稳定的状态：

- 平均响应时间：如`Sentinel`中的熔断就使用了平均响应时间，当 1s 内持续进入 5 个请求，对应时刻的平均响应时间（秒级）均超过阈值（`count`，以 ms 为单位），那么在接下的时间窗口之内，对这个方法的调用都会自动地熔断。
- 异常比例 ：主流的容错框架`Hystrix`和`sentinel`中都使用了异常比例熔断策略，比如当资源的每秒请求量 >= 5，并且每秒异常总数占通过量的比值超过阈值之后，资源进入熔断状态，即在接下的时间窗口之内，对这个方法的调用都会自动地返回。异常比率的阈值范围是 `[0.0, 1.0]`，代表 0% - 100%。
- 异常数：如`Sentinel`中的熔断就使用了异常数熔断策略，当资源近 1 分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若 `timeWindow` 小于 60s，则结束熔断状态后仍可能再进入熔断状态。

## 3. 限流机制

略。